<html>
    <head>
        <title>Zip Bombs</title>
        <link rel="icon" href="./Zip Bomb Files/zip-icon.svg">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="Author" content="Captain Chicky">
        <meta name="Keywords" content="zip, bomb, compression, zip bomb, chicky, captain chicky, article">
        <meta name="Description" content="Article about zip bombs.">
        <meta property="og:type" content="website">
        <meta property="og:title" content="Zip Bombs">
        <meta property="og:description" content="A [currently incomplete] article on zip bombs and the science behind them.">
        <meta property="og:url" content="https://captainchicky.github.io"> 
        <meta property="og:image" content="http://captainchicky.github.io/Zip-Bomb/Zip%20Bomb%20Files/zip-icon.png">
        <meta property="og:image:secure_url" content="https://captainchicky.github.io/Zip-Bomb/Zip%20Bomb%20Files/zip-icon.png"> 
        <meta property="og:image:width" content="256">
        <meta property="og:image:height" content="256">
        <meta property="og:image:alt" content="zip-icon">
        <style>
            .Example1div {
                font-size: 14px;
                display: block;
            }
            body {
                background-color: blanchedalmond;
            }
            p {
                color: navy;
                font-family: "Verdana", Sans-serif;
                margin-right: 375px;
            }
            h2 {
                padding-left: 25px;
                font-family: "Georgia", serif;
            }
            h3 {
                padding-left: 15px;
                color: midnightblue; 
            }
            h4 {
                padding-left: 5px;
                color:rgb(40, 69, 73)
            }
            blockquote {
                background: #ffdede;
                border-left: 10px solid rgb(161, 161, 161);
                margin: 1.5em 10px;
                margin-right: 400px;
                padding: 0.5em 10px;
                quotes: "\201C""\201D""\2018""\2019";
            }
            blockquote:before {
              color: #ccc;
              content: open-quote;
              font-size: 4em;
              line-height: 0.1em;
              margin-right: 0.25em;
              vertical-align: -0.4em;
            }
            blockquote p {
              display: inline;
            }
            span {
                color: darkblue;
                font-family: "Verdana", Sans-serif;
            }
            aside {
             	float: right;
            	clear: right;
              	width: 20vw;
             	margin-right: -1.5vw;
            	margin-bottom: 0.5rem;
            	background-color: rgba(0, 255, 255, 0.308);
            	font-size: 0.8rem;
              	padding: 0.5rem;
             	overflow: auto;
            }
            aside :first-child {
              	margin-top: 0;
            }
            aside :last-child {
               	margin-bottom: 0;
            }

        </style>
    </head>
    <body>
        <center>
            <h1><u><b>The Zip Bomb</b></u></h1>
        </center>
        <h2>What is a zip bomb?</h2>
        <p>First and foremost, let's start with the definitions.</p>
        <blockquote>
            A <b>zip bomb</b> is a <i>usually</i> malicious compressed file that is usually designed to render useless 
            an antivirus engine to create an opening for another computer virus.
        </blockquote>
        <p>
            Normally, a zip bomb negates an antivirus engine by tricking it into scanning the entire archive, 
            which takes up an unimaginably large amount of time, disk space, and memory. However, 
            modern antivirus engines are able to recongnize when a file is a zip bomb, and will avoid scanning through it.
        </p>
        <p>
            Despite this, what I'm looking at isn't its ability to destroy antivirus engines or create opening for other 
            viruses to attack - instead, let's take a look into the marvelous compression ability of zip bombs, and the science behind it.
        </p>
        <p>When talking about zip bombs, I will split them into two catagories:</p>
        <ol>
            <li><b>Traditional zip bombs.</b></li>
            <li><b>The "better" zip bombs.</b></li>
        </ol>
        <p>
            You have have heard of another type of "zip bomb": the <b>zip quine</b>. 
            However, I would like for you to note that this is an entirely different thing compared to a zip bomb. 
            While it <i>can</i> be used in theory to disable antivirus engines &c like how zip bombs do, 
            they are <i>much more sophisticated</i> compared to zip bombs and deserves its own article that I will write sometime in the future.
        </p>
        <p>That leaves us with the two types of zip bombs, the traditional and the better ones. So without further ado, let's take a look at them.</p>
        <h2>Traditional zip bombs</h2>
        <blockquote>
            <p>A <b>traditional zip bomb</b> is one that <i>uses recursive zipping to acheive high levels of compression.</i></p>
        </blockquote>
        <p>
            A zip bomb that use the .zip format
            must cope with the fact that the compression algorithm .zips most commonly use, <i>DEFLATE</i>,
            cannot achieve a compression ratio greater than 1032. Why? Well let's take a look.
        </p>
        <h3>
            Compression
        </h3>
        <h4>
            <u>Example 1</u>
        </h4>
        <p>
            First, let's understand what compression actually is. Take a look at the image below:
            <br><br>
            <img src="Zip Bomb Files/Figure1.png">
            <br><br>
            How would you describe this image?
            <br>
            Well, we can say that: <u>the <i>top-left box is blue</i>, the <i>top-middle box is blue</i>, the <i>top-right box is blue</i>, 
            the <i>middle-left box is blue</i>, the <i>middle-middle box is blue</i>, the <i>middle-right box is blue</i>,
            the <i>bottom-left box is blue</i>, the <i>bottom-middle box is blue</i>, and the <i>bottom right box is blue</i>.</u>
            <br><br>
            <i>Whew</i>, that was certainly a mouthful wasn't it? If you were trying to describe to someone this image in the most efficient and effective way,
            the method I used would certainly <b>not</b> be a viable one. So instead, let's try something else. 
            <br><br>
            How about this? We can say that: <u>there are <i>9 boxes</i>, arranged in a <i>3x3 pattern</i>, where <i>all the boxes are blue.</i></u>
            <br><br>
            That was certainly a much more efficient way of describing the image, without the redundancies of having to denote each box as blue individually.
            What we have done here, is what data compression does. It takes a file and subtracts the redundancies that may be contained in the file, effectively
            compressing it, lowering the file size.
            <br><br>
            Now notice something - we can shorten the description even further! Looking back at our "compressed" description, we see that we can take away 
            "<u>there are <i>9 boxes</i></u>" and still have our description be feasibly understood, and reconstructed perfectly.
            <br><br>
            This is an example of how different compression algorithms work, and how some are able to compress more than others in different cases. 
            They each have their own methods of reducing and eliminating redundant data within a file, while still maintaining the ability to perfectly
            reconstruct the original file itself - <i>lossless compression</i>.
            <br><br>
            Then there are <i>lossy compression</i> algorithms. Referring back to our aforementioned example, let's just say instead that <u><i>all boxes are blue</i></u>.
            We can see how this still describes our image, but when trying to reconstruct it, we don't know how many boxes there are. We can estimate that there may be
            around 4-16 of them, but we can't be sure, since there is no information regarding it after compression.
        </p>
        <p>
            Now, let's look at zip files. While zip files may use a variety of compression algorithms, the compression algorithm
            <i>DEFLATE</i> is the <a href="https://en.wikipedia.org/wiki/ZIP_(file_format)#:~:text=DEFLATE%20is%20the%20most%20common.">most common</a>.
            As a result, almost all zip bombs utilize this algorithm, and thus, we'll take a look at this algorithm in particular.
        </p>
        <p>
            Let's take a dive into a more rigorous example of compression. 
        </p>
        <h4>
            <u>Example 2</u>
        </h4>
        <p>
            In a typical file, the data is divided into <i>bytes</i>. Unless there is a special exception, a byte is 8 bits long, where a single bit is a 0 or a 1.
            In UTF-8 encoding, each byte represents a single character. For example, the character, and in this case, byte "0" is encoded by the bits "00110000". 
            Note that in other non-latin based languages, such as Chinese or Arabic, a character may be multiple bytes.
            <br><br>
            However, not every byte of data encodes as much information as others in a sense. For example, think of all the English words you can that start with "Q" or "T". 
            How many of them don't have a "U" or "H" immediately superceeding it? Likely none of them! Knowing this, how much "information" do you think the "U" and "H" 
            actually contain, in a sense? What if you omit the "U" and "H"s, or replace them with a single character?
            <br><br>
            Again, we can see the points I have shown in <div class="Example1div"><u><b>Example 1</b></u></div>
        </p>
        boundary lol
        <p>
            By intuition, and by the example above, a compression algorithm will work the best if a file is extremely redundant; for instance, a file filled with zeroes.
            So therefore, let's test how well <i>DEFLATE</i> can compress a file filled with a lot of zeroes.
            <br><br>
            Empirically, <i>DEFLATE</i> is capable of compression factors exceeding 1000:1. 
            You can test this by creating a <data value="50000000">50<abbr title=Megabyte(s)>MB</abbr></data> file filled with zeros and compress it using <i>DEFLATE</i>. 
            It should compress to be roughly around <data value="48605">49<abbr title=Kilobyte(s)>KB</abbr></data> as demonstrated <a href="./Zip Bomb Files/0.zip">here</a>.
        </p>
        <p>
            To find the theoretical limit, let's dive deeper into the <i>DEFLATE</i> algorithm and zip file structure itself.
            The limit comes from the fact that one length/distance pair can represent at most 258 output bytes. 
            A length requires at least one bit and a distance requires at least one bit, so two bits in can give 258 bytes out, 
            or eight bits in give 1032 bytes out. A dynamic block has no length restriction, so you could get arbitrarily close to the limit of 1032:1.
        </p>"Georgia", serif
        <p>
            We can also note that the current implementation limits its dynamic blocks to about <data value="8000">8<abbr title=Kilobyte(s)>KB</abbr></data> 
            (corresponding to <data value="8000000">8<abbr title=Megabyte(s)>MB</abbr></data> of input data); together with a few bits of overhead, this implies 
            an actual compression limit of about 1030.3:1. Not only that, but the compressed data stream is itself likely to be rather compressible 
            (in this special case only), so running it through <i>DEFLATE</i> again should produce further gains.
        </p>

        <p>
            Due to this reason, traditional zip bombs rely on recursive decompression, nesting zip files within zip files to get an extra factor of ~1032 with each layer.
            Referring back to the original purpose of these traditional zip bombs - to disable antiviruses, these nested zips will only work on antivirus engines
            that scan recursively into each nest of zips, and now as of March 2021, most will not. 
        </p>
        <aside>
            <span>
            I haven't been able to find the original author for 42.zip. If anyone knows, please ping me on twitter(profile link is on my github homepage).
            </span>
        </aside>
        <p>
            The best-known zip bomb, <a href="./42.html">42.zip</a>, expands to a formidable <data value="4503599626321920">4.5<abbr title=Petabyte(s)>PB</abbr></data> 
            if all six of its layers are fully and recursively unzipped, but a negligable <data value="558432">0.6<abbr title=Megabyte(s)>MB</abbr></data>
            if one were to only unzip the top layer.
        </p>
        <p>Tobecontinue</p>
    </body>
</html>