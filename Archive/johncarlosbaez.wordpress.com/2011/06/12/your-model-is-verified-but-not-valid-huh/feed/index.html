<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Your Model Is Verified, But Not Valid! Huh?	</title>
	<atom:link href="https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/feed/" rel="self" type="application/rss+xml" />
	<link>https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/</link>
	<description></description>
	<lastBuildDate>Wed, 22 Jun 2011 23:46:28 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
	<item>
		<title>
		By: Giampiero Campa		</title>
		<link>https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6438</link>

		<dc:creator><![CDATA[Giampiero Campa]]></dc:creator>
		<pubDate>Wed, 22 Jun 2011 23:46:28 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=4014#comment-6438</guid>

					<description><![CDATA[&lt;blockquote&gt;
I don’t think that it is possible to specify the interactions of system components in UML or any other graphical language I know in sufficient precision.
&lt;/blockquote&gt;

Well it&#039;s possible in Simulink (and it&#039;s actually very convenient because the blocks do not represent states but subsystems, so the diagram does not represent the &lt;i&gt;behavior&lt;/i&gt; but the &lt;i&gt;structure&lt;/i&gt; of the system). I would say that the fact that you can generate directly executable code also proves that the level of precision is sufficient. But i don&#039;t think this is a good environment to write high level requirements (and also if the interactions between subsystems is always two-way then this complicates things a little).

For diagrams that represent the behavior of the system, like FSM (and therefore UML), i think that representing the interactions of the systems is exceedingly hard and inconvenient, but probably theoretically possible, (since anything you can do with code you can also do with a FSM, that would be my reasoning).

In any case, i don&#039;t think using a graphical language for climate modeling is a good idea.]]></description>
			<content:encoded><![CDATA[<blockquote><p>
I don’t think that it is possible to specify the interactions of system components in UML or any other graphical language I know in sufficient precision.
</p></blockquote>
<p>Well it&#8217;s possible in Simulink (and it&#8217;s actually very convenient because the blocks do not represent states but subsystems, so the diagram does not represent the <i>behavior</i> but the <i>structure</i> of the system). I would say that the fact that you can generate directly executable code also proves that the level of precision is sufficient. But i don&#8217;t think this is a good environment to write high level requirements (and also if the interactions between subsystems is always two-way then this complicates things a little).</p>
<p>For diagrams that represent the behavior of the system, like FSM (and therefore UML), i think that representing the interactions of the systems is exceedingly hard and inconvenient, but probably theoretically possible, (since anything you can do with code you can also do with a FSM, that would be my reasoning).</p>
<p>In any case, i don&#8217;t think using a graphical language for climate modeling is a good idea.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Tim van Beek		</title>
		<link>https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6418</link>

		<dc:creator><![CDATA[Tim van Beek]]></dc:creator>
		<pubDate>Tue, 21 Jun 2011 07:16:49 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=4014#comment-6418</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6413&quot;&gt;Giampiero Campa&lt;/a&gt;.

I don&#039;t think that it is possible to specify the &lt;i&gt;interactions&lt;/i&gt; of system components in UML or any other graphical language I know in sufficient precision.
In my experience, in practice UML is used in this ways:

* entity-relationship diagrams are used to model the layout of relational database systems, up to the generation of DDL scripts (DDL = database definition language),

* class diagrams are used to specify the interfaces of components and are used to generate code stubs,

* interaction diagrams are used to specify specific complex processes, although Germans would typically use &quot;ereignisgesteuerte Prozessketten&quot; (&quot;event driven process chains&quot;, ARIS) for this purpose.

* Use Case diagrams are used as an illustration for, well, use cases.

The artefacts that are generated from UML are very limited, it works best for ER-diagrams -&#062; DDL scripts.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6413">Giampiero Campa</a>.</p>
<p>I don&#8217;t think that it is possible to specify the <i>interactions</i> of system components in UML or any other graphical language I know in sufficient precision.<br />
In my experience, in practice UML is used in this ways:</p>
<p>* entity-relationship diagrams are used to model the layout of relational database systems, up to the generation of DDL scripts (DDL = database definition language),</p>
<p>* class diagrams are used to specify the interfaces of components and are used to generate code stubs,</p>
<p>* interaction diagrams are used to specify specific complex processes, although Germans would typically use &#8220;ereignisgesteuerte Prozessketten&#8221; (&#8220;event driven process chains&#8221;, ARIS) for this purpose.</p>
<p>* Use Case diagrams are used as an illustration for, well, use cases.</p>
<p>The artefacts that are generated from UML are very limited, it works best for ER-diagrams -&gt; DDL scripts.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Giampiero Campa		</title>
		<link>https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6413</link>

		<dc:creator><![CDATA[Giampiero Campa]]></dc:creator>
		<pubDate>Tue, 21 Jun 2011 02:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=4014#comment-6413</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6406&quot;&gt;Tim van Beek&lt;/a&gt;.

&lt;blockquote&gt;
I don’t know about NASA, but in my world the UML diagrams are usually far from being a formal description of the system. 
&lt;/blockquote&gt;

Maybe on a very high level they could be, but anyway, in practice people do dot (and will never, IMHO) write specifications in UML, they use word or Doors, and then the requirements are traced back to block in diagrams (manually) and to the generated code (automatically). But then again i am mostly talking about model based design, which i know best.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6406">Tim van Beek</a>.</p>
<blockquote><p>
I don’t know about NASA, but in my world the UML diagrams are usually far from being a formal description of the system.
</p></blockquote>
<p>Maybe on a very high level they could be, but anyway, in practice people do dot (and will never, IMHO) write specifications in UML, they use word or Doors, and then the requirements are traced back to block in diagrams (manually) and to the generated code (automatically). But then again i am mostly talking about model based design, which i know best.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Tim van Beek		</title>
		<link>https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6407</link>

		<dc:creator><![CDATA[Tim van Beek]]></dc:creator>
		<pubDate>Mon, 20 Jun 2011 08:13:52 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=4014#comment-6407</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6401&quot;&gt;Jon Rowlands&lt;/a&gt;.

High expectations...]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6401">Jon Rowlands</a>.</p>
<p>High expectations&#8230;</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Tim van Beek		</title>
		<link>https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6406</link>

		<dc:creator><![CDATA[Tim van Beek]]></dc:creator>
		<pubDate>Mon, 20 Jun 2011 08:08:06 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=4014#comment-6406</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6404&quot;&gt;Giampiero Campa&lt;/a&gt;.

Giampiero wrote:
&lt;blockquote&gt;

The Verification problem nowadays can be solved automatically for practical purposes, by generating test cases that (try to) cover the whole behavior of the software, and automatically simulating the system for each case. There are pretty much well developed metrics to address the question of how much is good enough, in terms of model coverage.

&lt;/blockquote&gt;
For some purposes, certainly, but for all? I assume you are talking about unit tests and C0 and C1 code coverage as a metric. For the object oriented systems that I know of it is not possible to generate unit tests, because there is no formalized interface description. You have to write them by hand. To be honest, usually you have to refactor the code to make it amenable to unit testing in the first place...

&lt;blockquote&gt;

After hanging out in a few NASA-organized IV&#038;V conferences, i somehow also got the gist (but don’t hold me to that, i am not a V&#038;V engineer) that if one writes the requirements in a formal language (e.g. UML or FSMs) then one can use the same verification techniques to solve the validation problem. 

&lt;/blockquote&gt;
I don&#039;t know about NASA, but in my world the UML diagrams are usually far from being a formal description of the system. For a system that is developed for 10 years without any change in plans, this may work. Like for NASA&#039;s Mars missions. For other projects the requirements may change every month, week or even day. So even if you&#039;d happen to be able to write a complete system specification in a highly formal way in UML, it will certainly be obsolete before you are able to even begin to prove that it is &quot;correct&quot;.

&lt;blockquote&gt;

This seems to be especially convenient when you use code generation techniques to automatically generate lower level code from higher level description, as it is now routine in both Aerospace and Automotive industries. Then, at the end of the chain, static verification techniques also play a part in proving that there are no runtime errors (e.g. divisions by zero, and stuff like that) in the lower level code.

&lt;/blockquote&gt;
It&#039;s correct that nobody - AFAIK -in the automotive industry writes low level code for embedded microprocessors, for example; this code is generated. But in practice there are severe limitations to MDD (model driven design) and other abstraction techniques; I know many software projects that cannot go to a higher abstraction level than 4th generation programming languages, for good reasons.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6404">Giampiero Campa</a>.</p>
<p>Giampiero wrote:</p>
<blockquote>
<p>The Verification problem nowadays can be solved automatically for practical purposes, by generating test cases that (try to) cover the whole behavior of the software, and automatically simulating the system for each case. There are pretty much well developed metrics to address the question of how much is good enough, in terms of model coverage.</p>
</blockquote>
<p>For some purposes, certainly, but for all? I assume you are talking about unit tests and C0 and C1 code coverage as a metric. For the object oriented systems that I know of it is not possible to generate unit tests, because there is no formalized interface description. You have to write them by hand. To be honest, usually you have to refactor the code to make it amenable to unit testing in the first place&#8230;</p>
<blockquote>
<p>After hanging out in a few NASA-organized IV&amp;V conferences, i somehow also got the gist (but don’t hold me to that, i am not a V&amp;V engineer) that if one writes the requirements in a formal language (e.g. UML or FSMs) then one can use the same verification techniques to solve the validation problem. </p>
</blockquote>
<p>I don&#8217;t know about NASA, but in my world the UML diagrams are usually far from being a formal description of the system. For a system that is developed for 10 years without any change in plans, this may work. Like for NASA&#8217;s Mars missions. For other projects the requirements may change every month, week or even day. So even if you&#8217;d happen to be able to write a complete system specification in a highly formal way in UML, it will certainly be obsolete before you are able to even begin to prove that it is &#8220;correct&#8221;.</p>
<blockquote>
<p>This seems to be especially convenient when you use code generation techniques to automatically generate lower level code from higher level description, as it is now routine in both Aerospace and Automotive industries. Then, at the end of the chain, static verification techniques also play a part in proving that there are no runtime errors (e.g. divisions by zero, and stuff like that) in the lower level code.</p>
</blockquote>
<p>It&#8217;s correct that nobody &#8211; AFAIK -in the automotive industry writes low level code for embedded microprocessors, for example; this code is generated. But in practice there are severe limitations to MDD (model driven design) and other abstraction techniques; I know many software projects that cannot go to a higher abstraction level than 4th generation programming languages, for good reasons.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Giampiero Campa		</title>
		<link>https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6404</link>

		<dc:creator><![CDATA[Giampiero Campa]]></dc:creator>
		<pubDate>Mon, 20 Jun 2011 02:18:23 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=4014#comment-6404</guid>

					<description><![CDATA[As they sometimes say, Verification and Validation answer the following questions:

Validation: Are we building the right system ?
Verification: Are we building the system right ?

The Verification problem nowadays can be solved automatically for practical purposes, by generating test cases that (try to) cover the whole behavior of the software, and automatically simulating the system for each case. There are  pretty much well developed metrics to address the question of how much is good enough, in terms of model coverage.

After hanging out in a few NASA-organized IV&#038;V conferences, i somehow also got the gist (but don&#039;t hold me to that, i am not a V&#038;V engineer) that if one writes the requirements in a formal language (e.g. UML or FSMs) then one can use the same &lt;i&gt;verification&lt;/i&gt; techniques to solve the &lt;i&gt;validation&lt;/i&gt; problem. 

This seems to be especially convenient when you use code generation techniques to automatically generate lower level code from higher level description, as it is now routine in both Aerospace and Automotive industries. Then, at the end of the chain, static verification techniques also play a part in proving that there are no runtime errors (e.g. divisions by zero, and stuff like that)  in the lower level code.

Fascinating stuff.]]></description>
			<content:encoded><![CDATA[<p>As they sometimes say, Verification and Validation answer the following questions:</p>
<p>Validation: Are we building the right system ?<br />
Verification: Are we building the system right ?</p>
<p>The Verification problem nowadays can be solved automatically for practical purposes, by generating test cases that (try to) cover the whole behavior of the software, and automatically simulating the system for each case. There are  pretty much well developed metrics to address the question of how much is good enough, in terms of model coverage.</p>
<p>After hanging out in a few NASA-organized IV&amp;V conferences, i somehow also got the gist (but don&#8217;t hold me to that, i am not a V&amp;V engineer) that if one writes the requirements in a formal language (e.g. UML or FSMs) then one can use the same <i>verification</i> techniques to solve the <i>validation</i> problem. </p>
<p>This seems to be especially convenient when you use code generation techniques to automatically generate lower level code from higher level description, as it is now routine in both Aerospace and Automotive industries. Then, at the end of the chain, static verification techniques also play a part in proving that there are no runtime errors (e.g. divisions by zero, and stuff like that)  in the lower level code.</p>
<p>Fascinating stuff.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Jon Rowlands		</title>
		<link>https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6401</link>

		<dc:creator><![CDATA[Jon Rowlands]]></dc:creator>
		<pubDate>Sun, 19 Jun 2011 21:01:22 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=4014#comment-6401</guid>

					<description><![CDATA[The words “verification and validation” show the difficulty with abstraction. It’s much clearer (to me) to talk about code bugs and spec bugs, but V&#038;V is used beyond software, so that won’t do it for everyone. Personally what I’d like out of “green mathematics” is a toolkit for non-mathematicians of concepts, diagrams, design patterns and actual software for working with abstractions up and (especially) down a hierarchy.

I wasn’t aware, before composing this comment, that climate modeling is a pretty social activity. There are events and organizations dedicated to testing different models against each other (“intercomparison”), and it’s common to glue models together into useful hybrids (“integration”). Both of these require formalizing the ways different models relate to each other, probably via more abstractions.

Here’s the rub. Making abstractions is a little bit interesting, but progress occurs when whatever is learned is made concrete again. Comparing abstracted values from two models might show that one is faulty, but the work and the reward are to find and fix the problem. Similarly when two models interact dynamically, incoming insights need to be merged into each model’s concrete state in a self-consistent way.

It may be that navigating back down an abstraction is intrinsically hard and specific to each new problem. But it’s my impression that while we engineers cobble something together by hand from scratch each time, category theorists know about some reusable machinery. Hopefully there’s low hanging fruit.

For example though I’m still struggling to relate them to my field, the “constellation” diagrams of opetopes by Joachim Kock et al are intriguing for their simplicity. Contrast these to UML, the graphical language used in software engineering, which gives an ad-hoc grab bag of diagrams specialized for a few common abstractions, but not very useful for others.]]></description>
			<content:encoded><![CDATA[<p>The words “verification and validation” show the difficulty with abstraction. It’s much clearer (to me) to talk about code bugs and spec bugs, but V&amp;V is used beyond software, so that won’t do it for everyone. Personally what I’d like out of “green mathematics” is a toolkit for non-mathematicians of concepts, diagrams, design patterns and actual software for working with abstractions up and (especially) down a hierarchy.</p>
<p>I wasn’t aware, before composing this comment, that climate modeling is a pretty social activity. There are events and organizations dedicated to testing different models against each other (“intercomparison”), and it’s common to glue models together into useful hybrids (“integration”). Both of these require formalizing the ways different models relate to each other, probably via more abstractions.</p>
<p>Here’s the rub. Making abstractions is a little bit interesting, but progress occurs when whatever is learned is made concrete again. Comparing abstracted values from two models might show that one is faulty, but the work and the reward are to find and fix the problem. Similarly when two models interact dynamically, incoming insights need to be merged into each model’s concrete state in a self-consistent way.</p>
<p>It may be that navigating back down an abstraction is intrinsically hard and specific to each new problem. But it’s my impression that while we engineers cobble something together by hand from scratch each time, category theorists know about some reusable machinery. Hopefully there’s low hanging fruit.</p>
<p>For example though I’m still struggling to relate them to my field, the “constellation” diagrams of opetopes by Joachim Kock et al are intriguing for their simplicity. Contrast these to UML, the graphical language used in software engineering, which gives an ad-hoc grab bag of diagrams specialized for a few common abstractions, but not very useful for others.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Phil Henshaw		</title>
		<link>https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6358</link>

		<dc:creator><![CDATA[Phil Henshaw]]></dc:creator>
		<pubDate>Thu, 16 Jun 2011 12:35:46 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=4014#comment-6358</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6312&quot;&gt;Tim van Beek&lt;/a&gt;.

Yes of course, but science has yet to give proper attention to which is which, how to tell the difference between processes you might anticipate will change tomorrow and those unlikely to ever change.  

I wrote a paper on the technique needed, how to identify processes you can anticipate will change form for natural structural causes, called &quot;Models Learning Change&quot; http://www.cosmosandhistory.org/index.php/journal/article/view/176/295 that comes down to two things.    What it offers is a greatly enhanced way to anticipate when a model will become &quot;wrong&quot;, rather than wait for system failure like we have done with economics. 

One is that you need to ask the question, as failing to do that is remarkably clearly demonstrated in our global culture&#039;s firm commitment to a model for limitless acceleration of change in its own complexity and energy use.  The other is to use indications of seemingly constant proportional change as a signal to locate and identify the feedback network doing it and what will destabilize it.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6312">Tim van Beek</a>.</p>
<p>Yes of course, but science has yet to give proper attention to which is which, how to tell the difference between processes you might anticipate will change tomorrow and those unlikely to ever change.  </p>
<p>I wrote a paper on the technique needed, how to identify processes you can anticipate will change form for natural structural causes, called &#8220;Models Learning Change&#8221; <a href="http://www.cosmosandhistory.org/index.php/journal/article/view/176/295" rel="nofollow ugc">http://www.cosmosandhistory.org/index.php/journal/article/view/176/295</a> that comes down to two things.    What it offers is a greatly enhanced way to anticipate when a model will become &#8220;wrong&#8221;, rather than wait for system failure like we have done with economics. </p>
<p>One is that you need to ask the question, as failing to do that is remarkably clearly demonstrated in our global culture&#8217;s firm commitment to a model for limitless acceleration of change in its own complexity and energy use.  The other is to use indications of seemingly constant proportional change as a signal to locate and identify the feedback network doing it and what will destabilize it.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Staffan Liljegren		</title>
		<link>https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6356</link>

		<dc:creator><![CDATA[Staffan Liljegren]]></dc:creator>
		<pubDate>Thu, 16 Jun 2011 07:19:38 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=4014#comment-6356</guid>

					<description><![CDATA[Thanks for the recommendation Nick! What is its focus?]]></description>
			<content:encoded><![CDATA[<p>Thanks for the recommendation Nick! What is its focus?</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Tim van Beek		</title>
		<link>https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6355</link>

		<dc:creator><![CDATA[Tim van Beek]]></dc:creator>
		<pubDate>Thu, 16 Jun 2011 07:12:58 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=4014#comment-6355</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6354&quot;&gt;Tim van Beek&lt;/a&gt;.

Richardson&#039;s forecast factory is a good illustration of the reason why I don&#039;t think that computer models pose a new challenge to epistemology: It&#039;s not more than an advanced version of pen and paper. And I haven&#039;t seen philosophers discussing that the existence of pen and paper poses a fundamental challenge to the way humans aquire knowledge.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2011/06/12/your-model-is-verified-but-not-valid-huh/#comment-6354">Tim van Beek</a>.</p>
<p>Richardson&#8217;s forecast factory is a good illustration of the reason why I don&#8217;t think that computer models pose a new challenge to epistemology: It&#8217;s not more than an advanced version of pen and paper. And I haven&#8217;t seen philosophers discussing that the existence of pen and paper poses a fundamental challenge to the way humans aquire knowledge.</p>
]]></content:encoded>
		
			</item>
	</channel>
</rss>
