<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: RChain	</title>
	<atom:link href="https://johncarlosbaez.wordpress.com/2018/05/12/rchain/feed/" rel="self" type="application/rss+xml" />
	<link>https://johncarlosbaez.wordpress.com/2018/05/12/rchain/</link>
	<description></description>
	<lastBuildDate>Sat, 26 May 2018 07:02:00 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
	<item>
		<title>
		By: Kram Einsnulldreizwei		</title>
		<link>https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-121103</link>

		<dc:creator><![CDATA[Kram Einsnulldreizwei]]></dc:creator>
		<pubDate>Sat, 26 May 2018 07:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=24839#comment-121103</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016&quot;&gt;Kram Einsnulldreizwei&lt;/a&gt;.

Ok thanks. I see, I could include pictures too. That would have been a big improvement to many of the above comments. Oh well...]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016">Kram Einsnulldreizwei</a>.</p>
<p>Ok thanks. I see, I could include pictures too. That would have been a big improvement to many of the above comments. Oh well&#8230;</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: John Baez		</title>
		<link>https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120988</link>

		<dc:creator><![CDATA[John Baez]]></dc:creator>
		<pubDate>Fri, 25 May 2018 18:23:40 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=24839#comment-120988</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016&quot;&gt;Kram Einsnulldreizwei&lt;/a&gt;.

Right now I just have time for the easiest of your questions:

&lt;blockquote&gt;
  I meant to ask: What syntax do you use to get hyperlink text?
&lt;/blockquote&gt;

Half the time I use HTML:

&lt;code&gt;&#060;a href = &quot;http://math.ucr.edu/home/baez/&quot;&#062;my home page&#060;/a&#062;&lt;/code&gt;

and half the time I used Markdown, in the following manner:

&lt;code&gt;[my home page](http://math.ucr.edu/home/baez/)&lt;/code&gt;

&lt;blockquote&gt;
  But Markdown hasn’t really been standardized, and several subtly different versions are floating around, so saying “You can use Markdown” isn’t very clear. Is there a guide to the specific version of it, that you use on this blog?
&lt;/blockquote&gt;

You should be able to find one starting from &lt;a href=&quot;https://en.support.wordpress.com/markdown/&quot; rel=&quot;nofollow&quot;&gt;here&lt;/a&gt; since I&#039;m using some sort of default version of Markdown provided by Wordpress for its blogs.   But I don&#039;t know what it is.  I don&#039;t do anything fancy, so it seems like everything I try to do with Markdown works on this blog, the Azimuth Forum (which runs on forum software called &quot;Vanilla&quot;) and also the &lt;i&gt;n&lt;/i&gt;-Category Caf&#233; (which runs on software called &quot;Moveable Type&quot;, together with a lot of homebrewed extra features by Jacques Distler).

You&#039;re welcome to try stuff and see if it works; I don&#039;t mind spending 5 minutes a day fixing formatting problems and discussing them!]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016">Kram Einsnulldreizwei</a>.</p>
<p>Right now I just have time for the easiest of your questions:</p>
<blockquote><p>
  I meant to ask: What syntax do you use to get hyperlink text?
</p></blockquote>
<p>Half the time I use HTML:</p>
<p><code>&lt;a href = "http://math.ucr.edu/home/baez/"&gt;my home page&lt;/a&gt;</code></p>
<p>and half the time I used Markdown, in the following manner:</p>
<p><code>[my home page](http://math.ucr.edu/home/baez/)</code></p>
<blockquote><p>
  But Markdown hasn’t really been standardized, and several subtly different versions are floating around, so saying “You can use Markdown” isn’t very clear. Is there a guide to the specific version of it, that you use on this blog?
</p></blockquote>
<p>You should be able to find one starting from <a href="https://en.support.wordpress.com/markdown/" rel="nofollow">here</a> since I&#8217;m using some sort of default version of Markdown provided by WordPress for its blogs.   But I don&#8217;t know what it is.  I don&#8217;t do anything fancy, so it seems like everything I try to do with Markdown works on this blog, the Azimuth Forum (which runs on forum software called &#8220;Vanilla&#8221;) and also the <i>n</i>-Category Caf&eacute; (which runs on software called &#8220;Moveable Type&#8221;, together with a lot of homebrewed extra features by Jacques Distler).</p>
<p>You&#8217;re welcome to try stuff and see if it works; I don&#8217;t mind spending 5 minutes a day fixing formatting problems and discussing them!</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Kram Einsnulldreizwei		</title>
		<link>https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120876</link>

		<dc:creator><![CDATA[Kram Einsnulldreizwei]]></dc:creator>
		<pubDate>Fri, 25 May 2018 09:33:17 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=24839#comment-120876</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016&quot;&gt;Kram Einsnulldreizwei&lt;/a&gt;.

I was in a bit of a rush in my previous comment.

Two addenda:

My very last remark was about not preserving all resources.
I&#039;m pretty sure that&#039;s nonsense in that resource aware type system would do exactly this: Count how often each &lt;em&gt;variable&lt;/em&gt; is used. The combinators aren&#039;t variables. So they can be safely forgotten about.

And secondly, I also wanted to clarify what I meant by these constraints &quot;preserving composition&quot;:

Take any non-reduced (but reducible, i.e. it shouldn&#039;t be an infinite loop) small subsection Q of any given (reducible) program P and look at it separately. It will be a valid program on its own.

Now, reduce Q, turning it into Q_r.

Put Q_r back into the hole you cut into P, keeping all the wires in the same order. (Globular will also enforce the wiring order), obtaining a new program P&#039;.

Reducing P will yield P_r.
Reducing P&#039; will yield P&#039;_r.

My claim is, that (once again, being careful with infinite loops and such), P_r = P&#039;_r.

At least in behavior. (I believe that means they are eta-equivalent?)

Different execution order &lt;em&gt;may&lt;/em&gt; yield different exact layouts.
Some of that ought to be fixable as well, but I&#039;m not sure all is:

I did not, as yet, add certain evidently true restructuring rules to Copy: Since it simply copies an input, arbitrary trees of copy hanging at the same input will give the exact same outcomes. Only the number of Copies is important.
So Commutativity and Associativity will hold for them.
Adding these would be quite trivial. Maybe I&#039;ll make another update later just to get those relations as well.
I&#039;m not sure adding just those laws would be enough to make the above claim even stronger, saying they even are &lt;em&gt;exactly&lt;/em&gt; the same (in that shuffling around the way Copies are branched may transform one into the other).
That might well be the case though.

At any rate, my real point is that, if you keep this information around, you can plug in input-side the same stuff before and after reduction, and ultimately the behavior will be unchanged.

By deleting this information (especially the Eats which normally just disappear entirely), this could no longer be guaranteed. A reduced program would have a different number of inputs from an unreduced one, so you&#039;d need to plug in different programs to begin with. Composition of programs would no longer necessarily even type-check, and if it did, behaviors wouldn&#039;t have to be the same either, because, effectively, the wrong wires end up with the wrong inputs.

All this concerns vertical composition. I think there are no problems at all with horizontal composition which simply corresponds to tensoring together two programs to obtain a new program with the combined inputs and outputs side by side.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016">Kram Einsnulldreizwei</a>.</p>
<p>I was in a bit of a rush in my previous comment.</p>
<p>Two addenda:</p>
<p>My very last remark was about not preserving all resources.<br />
I&#8217;m pretty sure that&#8217;s nonsense in that resource aware type system would do exactly this: Count how often each <em>variable</em> is used. The combinators aren&#8217;t variables. So they can be safely forgotten about.</p>
<p>And secondly, I also wanted to clarify what I meant by these constraints &#8220;preserving composition&#8221;:</p>
<p>Take any non-reduced (but reducible, i.e. it shouldn&#8217;t be an infinite loop) small subsection Q of any given (reducible) program P and look at it separately. It will be a valid program on its own.</p>
<p>Now, reduce Q, turning it into Q_r.</p>
<p>Put Q_r back into the hole you cut into P, keeping all the wires in the same order. (Globular will also enforce the wiring order), obtaining a new program P&#8217;.</p>
<p>Reducing P will yield P_r.<br />
Reducing P&#8217; will yield P&#8217;_r.</p>
<p>My claim is, that (once again, being careful with infinite loops and such), P_r = P&#8217;_r.</p>
<p>At least in behavior. (I believe that means they are eta-equivalent?)</p>
<p>Different execution order <em>may</em> yield different exact layouts.<br />
Some of that ought to be fixable as well, but I&#8217;m not sure all is:</p>
<p>I did not, as yet, add certain evidently true restructuring rules to Copy: Since it simply copies an input, arbitrary trees of copy hanging at the same input will give the exact same outcomes. Only the number of Copies is important.<br />
So Commutativity and Associativity will hold for them.<br />
Adding these would be quite trivial. Maybe I&#8217;ll make another update later just to get those relations as well.<br />
I&#8217;m not sure adding just those laws would be enough to make the above claim even stronger, saying they even are <em>exactly</em> the same (in that shuffling around the way Copies are branched may transform one into the other).<br />
That might well be the case though.</p>
<p>At any rate, my real point is that, if you keep this information around, you can plug in input-side the same stuff before and after reduction, and ultimately the behavior will be unchanged.</p>
<p>By deleting this information (especially the Eats which normally just disappear entirely), this could no longer be guaranteed. A reduced program would have a different number of inputs from an unreduced one, so you&#8217;d need to plug in different programs to begin with. Composition of programs would no longer necessarily even type-check, and if it did, behaviors wouldn&#8217;t have to be the same either, because, effectively, the wrong wires end up with the wrong inputs.</p>
<p>All this concerns vertical composition. I think there are no problems at all with horizontal composition which simply corresponds to tensoring together two programs to obtain a new program with the combined inputs and outputs side by side.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Kram Einsnulldreizwei		</title>
		<link>https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120859</link>

		<dc:creator><![CDATA[Kram Einsnulldreizwei]]></dc:creator>
		<pubDate>Fri, 25 May 2018 08:23:10 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=24839#comment-120859</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016&quot;&gt;Kram Einsnulldreizwei&lt;/a&gt;.

I meant to ask: What syntax do you use to get hyperlink text?
I know some versions of Markdown have a neat and tidy syntax for that. I could, of course, also use HTML to accomplish it.
But Markdown hasn&#039;t really been standardized, and several subtly different versions are floating around, so saying &quot;You can use Markdown&quot; isn&#039;t very clear. Is there a guide to the specific version of it, that you use on this blog?

&lt;blockquote&gt;
  Whether Globular has the expressiveness to generate everything you want from these generators, and derive all the rules you want from a finite set of relations, is an open question.
&lt;/blockquote&gt;

I&#039;d love for somebody to tackle that question, because as far as I can tell, the answer would necessarily have to clarify these combinator calculi in some subtle way:

I faithfully built all the objects and all the rules. I don&#039;t see what could possibly be missing. If anything &lt;em&gt;is&lt;/em&gt; missing, it ought to be something really subtle.

At best, the whole thing may be underconstrained because certain actions the current construction allows may lead to invalid states. - But most of that is the typing problem. The actual untyped version of these calculi would allow those exact same problematic states.

The one exception sill is that instance of Copy in the Communication rule, as I already established.

But in the SKI calculus? I&#039;m pretty sure there&#039;s literally nothing. - Essentially by construction. The pieces come together to generate the exact same behavior as the actual calculus would. No deviation is possible. The biggest difference is, that I have to do several extra steps (rearranging different combinators) to get everything in position to be able to apply stuff in the first place. But as long as we&#039;re dealing with finite programs - no infinite rearrangement moves are required - this ought to work out.

I guess, &lt;em&gt;that&lt;/em&gt; could ultimately be the limitation? But infinitely large programs (in terms of symbols, not in terms of rewrites until halting, i.e. infinite loops) seem like a relatively minor edge case not to have.

Or if there is no limitation of any kind, that ought to have some rather fundamental implications within category theory, right?

I&#039;m not sure how to prove any of this though. All I can definitely do is: Show me an arbitrary valid string of SKI combinators. I can implement it in Globular and arrive at the same final form (assuming the string halts) as any other correct implementation would. (And if it doesn&#039;t halt, I&#039;ll run into the exact same loop. Also, where execution order matters, it&#039;ll matter for me as well.)

I&#039;m not quite sure what would have to be shown exactly. What conditions would I have to check to show, that this Globular implementation is fully faithful? If you have more insight into that, do you think you could give me a rough outline? Maybe I could actually do at least parts of such a proof.

&lt;blockquote&gt;
  I should just emphasize, though, that “expressiveness” is not the same as “computational power”.
&lt;/blockquote&gt;

I know. I didn&#039;t mean to suggest that. My point just was, if my goal is to compute arbitrary things, without any constraints on how easy or practical or what ever else it is, the SKI combinators alone would already be sufficient.
That was me saying I&#039;d really like some simple, small, proper examples of using these combinators to accomplish something that would be really hard to do with just SKI combinators, just so I could get a feeling for how these rules actually work in practice.
Like, what&#039;s the &quot;Hello World&quot; of rho-combinators?

&lt;blockquote&gt;
  You will be tempted to use finite products whenever you’re trying to duplicate or delete data: that’s what they’re good for. And that’s where you’re likely to run into a wall.
&lt;/blockquote&gt;

Oooh, ok, that&#039;s actually helpful. This may well be it.
So for the &lt;em&gt;most&lt;/em&gt; part, I do not have problems with duplication or deletion. That&#039;s what Copy and Eat are for, after all.
I &lt;em&gt;do&lt;/em&gt; run into what migh be considerd a problem at the very end though:
Globular always (sensibly) demands the same number of inputs. To accomplish that, I cannot copy raw inputs:

I can&#039;t tell Globular to make this:
https://imgur.com/KDfWrLo
be the same as this:
https://imgur.com/1w7qbln

Similarly, with Eat, I can&#039;t tell it to make this:
https://imgur.com/2koCBQB
be the same as this:
https://imgur.com/5gse58m

That being said, to me that&#039;s almost a feature: It preserves composability.

If you have some arbitrary program P where a bunch of Eats and Copies are left at the very bottom, at the inputs, if I then decide to take some &lt;em&gt;other&lt;/em&gt; arbitrary program P&#039; , the outputs of which would become inputs of P, it&#039;d still work. Globular basically can evaluate a program all the way to the point where it will tell you how often each input is used. I think that&#039;s actually useful to know?

Inputs that end up being just an Eat are ones that are used 0 times. - In the usual SKI combinator calculus, you would just drop these altogether.

Inputs that end up being a bunch of Copies are ones that are used n+1 times with n instances of Copy directly at that input.
In the usual SKI combinator calculus, each input would have be written as a variable labelled &quot;x&quot; or something, and so copying it is as simple as writing it down multiple times in various spots.

A fully reduced program in my Globular implementation might end up looking something like this:
https://imgur.com/5LoYmw5
(Usually you&#039;d also have some combinators, but this is a possible outcome.)

which is equivalent to something like

(((((x((((x(((x((x(x)))))))))))))))

whereas normal SKI combinator calculus would be like this:
https://imgur.com/10pMxzC
(and all the inputs have the same label &quot;x&quot;)

So if the limitation of this is, that I can&#039;t just forget about resources (similar, given my current understanding, to what some linear type system would actually be designed to do), then that certainly is a limitation, but, for many usecases, a useful one.

(Note, I do forget &lt;em&gt;some&lt;/em&gt; resources though: In particular, once the diagram is reduced, or equivalently, the program is run, there is no way to tell how many combinators I started with to get to this behavior. I effectively only keep close track of unknown/variable inputs. Because Globular requires me to do so.)]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016">Kram Einsnulldreizwei</a>.</p>
<p>I meant to ask: What syntax do you use to get hyperlink text?<br />
I know some versions of Markdown have a neat and tidy syntax for that. I could, of course, also use HTML to accomplish it.<br />
But Markdown hasn&#8217;t really been standardized, and several subtly different versions are floating around, so saying &#8220;You can use Markdown&#8221; isn&#8217;t very clear. Is there a guide to the specific version of it, that you use on this blog?</p>
<blockquote><p>
  Whether Globular has the expressiveness to generate everything you want from these generators, and derive all the rules you want from a finite set of relations, is an open question.
</p></blockquote>
<p>I&#8217;d love for somebody to tackle that question, because as far as I can tell, the answer would necessarily have to clarify these combinator calculi in some subtle way:</p>
<p>I faithfully built all the objects and all the rules. I don&#8217;t see what could possibly be missing. If anything <em>is</em> missing, it ought to be something really subtle.</p>
<p>At best, the whole thing may be underconstrained because certain actions the current construction allows may lead to invalid states. &#8211; But most of that is the typing problem. The actual untyped version of these calculi would allow those exact same problematic states.</p>
<p>The one exception sill is that instance of Copy in the Communication rule, as I already established.</p>
<p>But in the SKI calculus? I&#8217;m pretty sure there&#8217;s literally nothing. &#8211; Essentially by construction. The pieces come together to generate the exact same behavior as the actual calculus would. No deviation is possible. The biggest difference is, that I have to do several extra steps (rearranging different combinators) to get everything in position to be able to apply stuff in the first place. But as long as we&#8217;re dealing with finite programs &#8211; no infinite rearrangement moves are required &#8211; this ought to work out.</p>
<p>I guess, <em>that</em> could ultimately be the limitation? But infinitely large programs (in terms of symbols, not in terms of rewrites until halting, i.e. infinite loops) seem like a relatively minor edge case not to have.</p>
<p>Or if there is no limitation of any kind, that ought to have some rather fundamental implications within category theory, right?</p>
<p>I&#8217;m not sure how to prove any of this though. All I can definitely do is: Show me an arbitrary valid string of SKI combinators. I can implement it in Globular and arrive at the same final form (assuming the string halts) as any other correct implementation would. (And if it doesn&#8217;t halt, I&#8217;ll run into the exact same loop. Also, where execution order matters, it&#8217;ll matter for me as well.)</p>
<p>I&#8217;m not quite sure what would have to be shown exactly. What conditions would I have to check to show, that this Globular implementation is fully faithful? If you have more insight into that, do you think you could give me a rough outline? Maybe I could actually do at least parts of such a proof.</p>
<blockquote><p>
  I should just emphasize, though, that “expressiveness” is not the same as “computational power”.
</p></blockquote>
<p>I know. I didn&#8217;t mean to suggest that. My point just was, if my goal is to compute arbitrary things, without any constraints on how easy or practical or what ever else it is, the SKI combinators alone would already be sufficient.<br />
That was me saying I&#8217;d really like some simple, small, proper examples of using these combinators to accomplish something that would be really hard to do with just SKI combinators, just so I could get a feeling for how these rules actually work in practice.<br />
Like, what&#8217;s the &#8220;Hello World&#8221; of rho-combinators?</p>
<blockquote><p>
  You will be tempted to use finite products whenever you’re trying to duplicate or delete data: that’s what they’re good for. And that’s where you’re likely to run into a wall.
</p></blockquote>
<p>Oooh, ok, that&#8217;s actually helpful. This may well be it.<br />
So for the <em>most</em> part, I do not have problems with duplication or deletion. That&#8217;s what Copy and Eat are for, after all.<br />
I <em>do</em> run into what migh be considerd a problem at the very end though:<br />
Globular always (sensibly) demands the same number of inputs. To accomplish that, I cannot copy raw inputs:</p>
<p>I can&#8217;t tell Globular to make this:<br />
<a href="https://imgur.com/KDfWrLo" rel="nofollow ugc">https://imgur.com/KDfWrLo</a><br />
be the same as this:<br />
<a href="https://imgur.com/1w7qbln" rel="nofollow ugc">https://imgur.com/1w7qbln</a></p>
<p>Similarly, with Eat, I can&#8217;t tell it to make this:<br />
<a href="https://imgur.com/2koCBQB" rel="nofollow ugc">https://imgur.com/2koCBQB</a><br />
be the same as this:<br />
<a href="https://imgur.com/5gse58m" rel="nofollow ugc">https://imgur.com/5gse58m</a></p>
<p>That being said, to me that&#8217;s almost a feature: It preserves composability.</p>
<p>If you have some arbitrary program P where a bunch of Eats and Copies are left at the very bottom, at the inputs, if I then decide to take some <em>other</em> arbitrary program P&#8217; , the outputs of which would become inputs of P, it&#8217;d still work. Globular basically can evaluate a program all the way to the point where it will tell you how often each input is used. I think that&#8217;s actually useful to know?</p>
<p>Inputs that end up being just an Eat are ones that are used 0 times. &#8211; In the usual SKI combinator calculus, you would just drop these altogether.</p>
<p>Inputs that end up being a bunch of Copies are ones that are used n+1 times with n instances of Copy directly at that input.<br />
In the usual SKI combinator calculus, each input would have be written as a variable labelled &#8220;x&#8221; or something, and so copying it is as simple as writing it down multiple times in various spots.</p>
<p>A fully reduced program in my Globular implementation might end up looking something like this:<br />
<a href="https://imgur.com/5LoYmw5" rel="nofollow ugc">https://imgur.com/5LoYmw5</a><br />
(Usually you&#8217;d also have some combinators, but this is a possible outcome.)</p>
<p>which is equivalent to something like</p>
<p>(((((x((((x(((x((x(x)))))))))))))))</p>
<p>whereas normal SKI combinator calculus would be like this:<br />
<a href="https://imgur.com/10pMxzC" rel="nofollow ugc">https://imgur.com/10pMxzC</a><br />
(and all the inputs have the same label &#8220;x&#8221;)</p>
<p>So if the limitation of this is, that I can&#8217;t just forget about resources (similar, given my current understanding, to what some linear type system would actually be designed to do), then that certainly is a limitation, but, for many usecases, a useful one.</p>
<p>(Note, I do forget <em>some</em> resources though: In particular, once the diagram is reduced, or equivalently, the program is run, there is no way to tell how many combinators I started with to get to this behavior. I effectively only keep close track of unknown/variable inputs. Because Globular requires me to do so.)</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: John Baez		</title>
		<link>https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120759</link>

		<dc:creator><![CDATA[John Baez]]></dc:creator>
		<pubDate>Thu, 24 May 2018 23:11:31 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=24839#comment-120759</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016&quot;&gt;Kram Einsnulldreizwei&lt;/a&gt;.

Kram wrote:

&lt;blockquote&gt;
  So in this example, would the generators be the combinators, and the relations their various rules?
&lt;/blockquote&gt;

That&#039;s the idea.  Whether Globular has the expressiveness to generate everything you want from these generators, and derive all the rules you want from a finite set of relations, is an open question.   It can only generate new things from your generators using the operations in a semistrict n-categories, and similarly it can only derive new rules from the relations you state using the rules of a semistrict n-category.

There are many different kinds of logical system, with varying amounts of expressiveness.  Globular is intentionally close to the bottom of the expressiveness hierarchy except in one respect, namely it allows a higher &quot;n&quot; (as in n-category) than almost any other system.  So, I&#039;d be surprised if the expressiveness of an ordinary computer programming language, even a simplified one like the lambda-calculus or SKI combinator calculus, can be captured by Globular.  But who knows?  Maybe I&#039;m confused.

&lt;blockquote&gt;
  Like, the SKI combinators themselves are already Turing complete, right?
&lt;/blockquote&gt;

Right.  I should just emphasize, though, that &lt;a href=&quot;https://en.wikipedia.org/wiki/Expressive_power_(computer_science)&quot; rel=&quot;nofollow&quot;&gt;&quot;expressiveness&quot;&lt;/a&gt; is not the same as &quot;computational power&quot;.  You can click the link to learn more about expressiveness, though probably not the really good math stuff.  Suffice it to say that expressiveness is one reason most people prefer C+ to machine language, even though both are Turing complete.

Jamie wrote:

&lt;blockquote&gt;
  Globular lets you work with any finitely-presented algebraic signature up to dimension 4, as long as the terms are purely compositional.
  
  I’m not sure, I fully understand every implication of this, but it seems to me, that a large set of combinator calculi fit this description.
&lt;/blockquote&gt;

Don&#039;t jump to that conclusion: the phrases &quot;algebraic signature&quot; and &quot;purely compositional&quot; are crucial here.

&lt;blockquote&gt;
  Unrelatedly, I stumbled over this: https://ncatlab.org/nlab/show/Lawvere+theory Which may give a more general answer to Jamie?  Lawvere theories are categories with finite products.
&lt;/blockquote&gt;

Right---and n-categories don&#039;t have finite products unless you demand that they do, and Globular doesn&#039;t allow you to demand that, so Globular probably can&#039;t do all sorts of stuff that Lawvere theories (or graph-enriched Lawvere theories) can do.

Finite products are a key aspect of &quot;expressiveness&quot; that Jamie is deliberately _not _trying to include.   You will be tempted to use finite products whenever you&#039;re trying to duplicate or delete data: that&#039;s what they&#039;re good for.   And that&#039;s where you&#039;re likely to run into a wall.

I would have to really carefully examine what you&#039;re doing, to see if you&#039;re somehow getting around this wall.  Unfortunately I don&#039;t have time.

As Jamie noted, you can use Globular to handle finitely presented &lt;a href=&quot;https://en.wikipedia.org/wiki/PRO_(category_theory)&quot; rel=&quot;nofollow&quot;&gt;PROs&lt;/a&gt;, and I believe you can also use it to handle finitely presented &lt;a href=&quot;https://ncatlab.org/nlab/show/PROP&quot; rel=&quot;nofollow&quot;&gt;PROPs&lt;/a&gt;.   PROPs are in the same ball-park as Lawvere theories, but they&#039;re less expressive.  For example there&#039;s a Lawvere theory for groups, but not a PROP for monoids, because groups have an axiom

$latex gg^{-1} = 1 $

in which the letter $latex g$ is duplicated on the left side and deleted on the right side.

This is a long, fun story but I&#039;ve told it &lt;a href=&quot;http://math.ucr.edu/home/baez/universal/&quot; rel=&quot;nofollow&quot;&gt;too many times in my life&lt;/a&gt; to tell it again now.

A random other issue:

&lt;blockquote&gt;
  What would the j be here? Simply the cell level? Or perhaps one less than the cell level?
&lt;/blockquote&gt;

The same as the cell level.   A &quot;j-morphism&quot; is a &quot;j-cell&quot; is a &quot;cell of dimension j&quot;, where j = 0, 1, 2, 3, ...]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016">Kram Einsnulldreizwei</a>.</p>
<p>Kram wrote:</p>
<blockquote><p>
  So in this example, would the generators be the combinators, and the relations their various rules?
</p></blockquote>
<p>That&#8217;s the idea.  Whether Globular has the expressiveness to generate everything you want from these generators, and derive all the rules you want from a finite set of relations, is an open question.   It can only generate new things from your generators using the operations in a semistrict n-categories, and similarly it can only derive new rules from the relations you state using the rules of a semistrict n-category.</p>
<p>There are many different kinds of logical system, with varying amounts of expressiveness.  Globular is intentionally close to the bottom of the expressiveness hierarchy except in one respect, namely it allows a higher &#8220;n&#8221; (as in n-category) than almost any other system.  So, I&#8217;d be surprised if the expressiveness of an ordinary computer programming language, even a simplified one like the lambda-calculus or SKI combinator calculus, can be captured by Globular.  But who knows?  Maybe I&#8217;m confused.</p>
<blockquote><p>
  Like, the SKI combinators themselves are already Turing complete, right?
</p></blockquote>
<p>Right.  I should just emphasize, though, that <a href="https://en.wikipedia.org/wiki/Expressive_power_(computer_science)" rel="nofollow">&#8220;expressiveness&#8221;</a> is not the same as &#8220;computational power&#8221;.  You can click the link to learn more about expressiveness, though probably not the really good math stuff.  Suffice it to say that expressiveness is one reason most people prefer C+ to machine language, even though both are Turing complete.</p>
<p>Jamie wrote:</p>
<blockquote><p>
  Globular lets you work with any finitely-presented algebraic signature up to dimension 4, as long as the terms are purely compositional.</p>
<p>  I’m not sure, I fully understand every implication of this, but it seems to me, that a large set of combinator calculi fit this description.
</p></blockquote>
<p>Don&#8217;t jump to that conclusion: the phrases &#8220;algebraic signature&#8221; and &#8220;purely compositional&#8221; are crucial here.</p>
<blockquote><p>
  Unrelatedly, I stumbled over this: <a href="https://ncatlab.org/nlab/show/Lawvere+theory" rel="nofollow ugc">https://ncatlab.org/nlab/show/Lawvere+theory</a> Which may give a more general answer to Jamie?  Lawvere theories are categories with finite products.
</p></blockquote>
<p>Right&#8212;and n-categories don&#8217;t have finite products unless you demand that they do, and Globular doesn&#8217;t allow you to demand that, so Globular probably can&#8217;t do all sorts of stuff that Lawvere theories (or graph-enriched Lawvere theories) can do.</p>
<p>Finite products are a key aspect of &#8220;expressiveness&#8221; that Jamie is deliberately _not _trying to include.   You will be tempted to use finite products whenever you&#8217;re trying to duplicate or delete data: that&#8217;s what they&#8217;re good for.   And that&#8217;s where you&#8217;re likely to run into a wall.</p>
<p>I would have to really carefully examine what you&#8217;re doing, to see if you&#8217;re somehow getting around this wall.  Unfortunately I don&#8217;t have time.</p>
<p>As Jamie noted, you can use Globular to handle finitely presented <a href="https://en.wikipedia.org/wiki/PRO_(category_theory)" rel="nofollow">PROs</a>, and I believe you can also use it to handle finitely presented <a href="https://ncatlab.org/nlab/show/PROP" rel="nofollow">PROPs</a>.   PROPs are in the same ball-park as Lawvere theories, but they&#8217;re less expressive.  For example there&#8217;s a Lawvere theory for groups, but not a PROP for monoids, because groups have an axiom</p>
<p><img src="https://s0.wp.com/latex.php?latex=gg%5E%7B-1%7D+%3D+1+&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" alt="gg^{-1} = 1 " class="latex" /></p>
<p>in which the letter <img src="https://s0.wp.com/latex.php?latex=g&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" alt="g" class="latex" /> is duplicated on the left side and deleted on the right side.</p>
<p>This is a long, fun story but I&#8217;ve told it <a href="http://math.ucr.edu/home/baez/universal/" rel="nofollow">too many times in my life</a> to tell it again now.</p>
<p>A random other issue:</p>
<blockquote><p>
  What would the j be here? Simply the cell level? Or perhaps one less than the cell level?
</p></blockquote>
<p>The same as the cell level.   A &#8220;j-morphism&#8221; is a &#8220;j-cell&#8221; is a &#8220;cell of dimension j&#8221;, where j = 0, 1, 2, 3, &#8230;</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Kram Einsnulldreizwei		</title>
		<link>https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120700</link>

		<dc:creator><![CDATA[Kram Einsnulldreizwei]]></dc:creator>
		<pubDate>Thu, 24 May 2018 17:55:07 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=24839#comment-120700</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016&quot;&gt;Kram Einsnulldreizwei&lt;/a&gt;.

Thanks, Jamie. I see.

As far as I can tell, the paper &lt;em&gt;does&lt;/em&gt; require products here but only explicitly shows them here (minimal paraphrasing):
$latex \left(\left(K y\right) z \right)$ is shorthand for $latex \ T \times T \xrightarrow{{left}^{-1}} 1 \times T \times T  \xrightarrow{K \times T \times T} T \times T \times T  \xrightarrow{\left(- \ -\right) \times T} 
T \times T \xrightarrow{\left( - \ - \right)} T$

Which clearly features a bunch of products.

But I believe, all that is, is a different way to write down the following diagram:

https://imgur.com/5VVTHlV

Read the picture from bottom to top and, in parallel, the above equation from left to right:

At first, I have two inputs T×T (i.e. composed side by side).
Then, left of that, I introduce a combinator, making it 1×T×T
It&#039;s the K combinator, which has a single output wire, so now it&#039;s T×T×T - three wires side by side.
Next up, I hit a branch of type T×T-&#062;T (or, curried, T-&#062;T-&#062;T), combining the two wires on the left, so as I cross that, I end up with T×T again.
Finally, I hit another branch, combining the remaining wires into one, giving me just T.

Here I did an overlay, trying to line up how the equation and the diagram correspond. Due to the way Globular lays out things, it got a little cramped in the bottom half.
https://imgur.com/0A9hfbw

So if I&#039;m right, I essentially emulated  products, to the extend they are needed here, by horizontal composition.
(Or it would be horizontal composition, if I hadn&#039;t skipped two cell levels to get better-behaved wires. - Throughout the paper, they write, that it only requires 2-categories to model all this. And if I manually added all the wire interaction rules like interchange laws and such, which Globular gives me for 4-categories, already at the 2-cell level, it&#039;d be true for my implementation as well.)

Horizontal composition is the 2-category version of the composition already available at the 1-category level, right? If I&#039;m not mistaken, it&#039;s the vertical composition that&#039;s new. Or did I get those turned around?

Regardless, meanwhile, vertical composition is used for introducing all the relevant structures which, in the above equation, show up as various morphisms.

In the overlay version of the image, horizontal composition is blue, vertical composition is red.

The entire rest of the paper doesn&#039;t reference products at all, as far as I could tell. It&#039;s all hidden behind the various strings of combinators and parentheses as, apparently, a form of syntactic sugar.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016">Kram Einsnulldreizwei</a>.</p>
<p>Thanks, Jamie. I see.</p>
<p>As far as I can tell, the paper <em>does</em> require products here but only explicitly shows them here (minimal paraphrasing):<br />
<img src="https://s0.wp.com/latex.php?latex=%5Cleft%28%5Cleft%28K+y%5Cright%29+z+%5Cright%29&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" alt="&#92;left(&#92;left(K y&#92;right) z &#92;right)" class="latex" /> is shorthand for <img src="https://s0.wp.com/latex.php?latex=%5C+T+%5Ctimes+T+%5Cxrightarrow%7B%7Bleft%7D%5E%7B-1%7D%7D+1+%5Ctimes+T+%5Ctimes+T++%5Cxrightarrow%7BK+%5Ctimes+T+%5Ctimes+T%7D+T+%5Ctimes+T+%5Ctimes+T++%5Cxrightarrow%7B%5Cleft%28-+%5C+-%5Cright%29+%5Ctimes+T%7D++T+%5Ctimes+T+%5Cxrightarrow%7B%5Cleft%28+-+%5C+-+%5Cright%29%7D+T&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" alt="&#92; T &#92;times T &#92;xrightarrow{{left}^{-1}} 1 &#92;times T &#92;times T  &#92;xrightarrow{K &#92;times T &#92;times T} T &#92;times T &#92;times T  &#92;xrightarrow{&#92;left(- &#92; -&#92;right) &#92;times T}  T &#92;times T &#92;xrightarrow{&#92;left( - &#92; - &#92;right)} T" class="latex" /></p>
<p>Which clearly features a bunch of products.</p>
<p>But I believe, all that is, is a different way to write down the following diagram:</p>
<p><a href="https://imgur.com/5VVTHlV" rel="nofollow ugc">https://imgur.com/5VVTHlV</a></p>
<p>Read the picture from bottom to top and, in parallel, the above equation from left to right:</p>
<p>At first, I have two inputs T×T (i.e. composed side by side).<br />
Then, left of that, I introduce a combinator, making it 1×T×T<br />
It&#8217;s the K combinator, which has a single output wire, so now it&#8217;s T×T×T &#8211; three wires side by side.<br />
Next up, I hit a branch of type T×T-&gt;T (or, curried, T-&gt;T-&gt;T), combining the two wires on the left, so as I cross that, I end up with T×T again.<br />
Finally, I hit another branch, combining the remaining wires into one, giving me just T.</p>
<p>Here I did an overlay, trying to line up how the equation and the diagram correspond. Due to the way Globular lays out things, it got a little cramped in the bottom half.<br />
<a href="https://imgur.com/0A9hfbw" rel="nofollow ugc">https://imgur.com/0A9hfbw</a></p>
<p>So if I&#8217;m right, I essentially emulated  products, to the extend they are needed here, by horizontal composition.<br />
(Or it would be horizontal composition, if I hadn&#8217;t skipped two cell levels to get better-behaved wires. &#8211; Throughout the paper, they write, that it only requires 2-categories to model all this. And if I manually added all the wire interaction rules like interchange laws and such, which Globular gives me for 4-categories, already at the 2-cell level, it&#8217;d be true for my implementation as well.)</p>
<p>Horizontal composition is the 2-category version of the composition already available at the 1-category level, right? If I&#8217;m not mistaken, it&#8217;s the vertical composition that&#8217;s new. Or did I get those turned around?</p>
<p>Regardless, meanwhile, vertical composition is used for introducing all the relevant structures which, in the above equation, show up as various morphisms.</p>
<p>In the overlay version of the image, horizontal composition is blue, vertical composition is red.</p>
<p>The entire rest of the paper doesn&#8217;t reference products at all, as far as I could tell. It&#8217;s all hidden behind the various strings of combinators and parentheses as, apparently, a form of syntactic sugar.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Jamie Vicary		</title>
		<link>https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120638</link>

		<dc:creator><![CDATA[Jamie Vicary]]></dc:creator>
		<pubDate>Thu, 24 May 2018 11:49:18 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=24839#comment-120638</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016&quot;&gt;Kram Einsnulldreizwei&lt;/a&gt;.

Hi both, thanks for your comments. The notion of Lawvere theory is definitely a related concept: it describes a finitely presented monoidal category with products. This is similar to what you can do in Globular, except Globular doesn&#039;t know about products. The more appropriate that Globular generalizes is PRO: finitely presented monoidal categories without the property that the monoidal structure is cartesian.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016">Kram Einsnulldreizwei</a>.</p>
<p>Hi both, thanks for your comments. The notion of Lawvere theory is definitely a related concept: it describes a finitely presented monoidal category with products. This is similar to what you can do in Globular, except Globular doesn&#8217;t know about products. The more appropriate that Globular generalizes is PRO: finitely presented monoidal categories without the property that the monoidal structure is cartesian.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Kram Einsnulldreizwei		</title>
		<link>https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120611</link>

		<dc:creator><![CDATA[Kram Einsnulldreizwei]]></dc:creator>
		<pubDate>Thu, 24 May 2018 09:22:52 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=24839#comment-120611</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016&quot;&gt;Kram Einsnulldreizwei&lt;/a&gt;.

Thanks for the explanation, John.

So in this example, would the generators be the combinators, and the relations their various rules?

As far as I can tell, I have:


An object env
(implicitly) the identity morphisms


1_2: Id(Id(env))
1: Id(Id(Id(env)))

A morphism of wires T: 1_2 -&#062; 1_2
a bunch of morphisms of type 1-&#062;T, which are my combinators
three extra morphisms 


Eat: T -&#062; 1
Copy: T -&#062; T×T
Branch: T×T -&#062; T
from which all valid (and as yet some invalid) programs can be built (I think)
and, defined with all these, morphisms one level up, that give me the relations between them, from which all other valid equations can be derived via appropriate usage of composition and identity.



What would the j be here? Simply the cell level? Or perhaps one less than the cell level? (I.e. do you count what dimension the morphism lives in, or objects of what dimension the morphism connects?)
Or is that something entirely else?
Because I wasn&#039;t sure, I dropped the j in the above.

Quick googling found me this as first/best match: https://ncatlab.org/nlab/show/J-homomorphism but I don&#039;t know if that&#039;s related.

Unrelatedly, I stumbled over this:
https://ncatlab.org/nlab/show/Lawvere+theory
Which may give a more general answer to Jamie?
Lawvere theories are categories with finite products.

&lt;blockquote&gt;
  The rough idea is to define an algebraic theory as a category with finite products and possessing a “generic algebra” (e.g., a generic group), and then define a model of that theory (e.g., a group) as a product-preserving functor out of that category.
&lt;/blockquote&gt;

It might be, that the group in question must itself be finitely presentable for it to work? But either way, that at least &lt;em&gt;sounds&lt;/em&gt; like it will mostly satisfy Globular&#039;s constraints.

That being said, we&#039;re dealing here with Graph-enriched theories, about which the paper by Michael Stay and L.G. Meredith ( https://arxiv.org/abs/1704.03080 ) states:

&lt;blockquote&gt;
  Gph is the category of graphs and graph homomorphisms. Gph has finite products.
&lt;/blockquote&gt;

and

&lt;blockquote&gt;
  A Gph-enriched category has finite products if the underlying
  category does.
&lt;/blockquote&gt;

Meaning, we&#039;re still dealing with finite products.

We&#039;re also dealing with multisorted Lawvere theories, and that&#039;s a tougher nut to crack. To get the full, correctly typed (/sorted) theory, we seemingly need infinitely many sorts.
My upcoming approach is, to try to make that, too, work by exploiting the fact, that we are only talking about two generator sorts, W and N, here, so perhaps I can finitely represent all the required sorts. (The biggest challenge here will be the S combinator)

Interestingly, about the sorts, the paper also states:

&lt;blockquote&gt;
  A multisorted Gph-enriched Lawvere theory, hereafter
  Gph-theory is a Gph-enriched category with finite products Th equipped with a finite set S of sorts and a Gph-enriched functor θ : FinSetop/S → Th that preserves products strictly.
&lt;/blockquote&gt;

The set of sorts is also finite. Presumably, things like N-&#062;W aren&#039;t counted as sorts in that set, then.

Finally, the very first sentence of 4, states:

&lt;blockquote&gt;
  Lawvere theories and their generalizations are categories with infinitely many objects and morphisms, but most theories of interest are finitely generated.
&lt;/blockquote&gt;

Which is vaguely related to my statement above, that most combinator calculi should admit a similar embedding into Globular, because the most interesting ones are finitely generated.

Below that, it states:

&lt;blockquote&gt;
  A presentation of the underlying multisorted Lawvere theory of a finitely-generated Gph-theory is a signature for a term calculus, consisting of a set of sorts, a set of term constructors, and a set of equations, while the edges in the hom graphs of the theory encode the reduction relation.
&lt;/blockquote&gt;

And after that, it presents the SKI combinator calculus as a Gph-theory, doing, as far as I can tell, pretty much 1:1 what I did.

(My single wire is the mentioned set of sorts, the various combinators and the three special morphisms are the set of term constructors, and after that I have the set of equations and reduction relations)

So while I absolutely might be missing something, I think that should pretty much answer Jamie&#039;s questions about whether this work can be represented in Globular.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016">Kram Einsnulldreizwei</a>.</p>
<p>Thanks for the explanation, John.</p>
<p>So in this example, would the generators be the combinators, and the relations their various rules?</p>
<p>As far as I can tell, I have:</p>
<p>An object env<br />
(implicitly) the identity morphisms</p>
<p>1_2: Id(Id(env))<br />
1: Id(Id(Id(env)))</p>
<p>A morphism of wires T: 1_2 -&gt; 1_2<br />
a bunch of morphisms of type 1-&gt;T, which are my combinators<br />
three extra morphisms </p>
<p>Eat: T -&gt; 1<br />
Copy: T -&gt; T×T<br />
Branch: T×T -&gt; T<br />
from which all valid (and as yet some invalid) programs can be built (I think)<br />
and, defined with all these, morphisms one level up, that give me the relations between them, from which all other valid equations can be derived via appropriate usage of composition and identity.</p>
<p>What would the j be here? Simply the cell level? Or perhaps one less than the cell level? (I.e. do you count what dimension the morphism lives in, or objects of what dimension the morphism connects?)<br />
Or is that something entirely else?<br />
Because I wasn&#8217;t sure, I dropped the j in the above.</p>
<p>Quick googling found me this as first/best match: <a href="https://ncatlab.org/nlab/show/J-homomorphism" rel="nofollow ugc">https://ncatlab.org/nlab/show/J-homomorphism</a> but I don&#8217;t know if that&#8217;s related.</p>
<p>Unrelatedly, I stumbled over this:<br />
<a href="https://ncatlab.org/nlab/show/Lawvere+theory" rel="nofollow ugc">https://ncatlab.org/nlab/show/Lawvere+theory</a><br />
Which may give a more general answer to Jamie?<br />
Lawvere theories are categories with finite products.</p>
<blockquote><p>
  The rough idea is to define an algebraic theory as a category with finite products and possessing a “generic algebra” (e.g., a generic group), and then define a model of that theory (e.g., a group) as a product-preserving functor out of that category.
</p></blockquote>
<p>It might be, that the group in question must itself be finitely presentable for it to work? But either way, that at least <em>sounds</em> like it will mostly satisfy Globular&#8217;s constraints.</p>
<p>That being said, we&#8217;re dealing here with Graph-enriched theories, about which the paper by Michael Stay and L.G. Meredith ( <a href="https://arxiv.org/abs/1704.03080" rel="nofollow ugc">https://arxiv.org/abs/1704.03080</a> ) states:</p>
<blockquote><p>
  Gph is the category of graphs and graph homomorphisms. Gph has finite products.
</p></blockquote>
<p>and</p>
<blockquote><p>
  A Gph-enriched category has finite products if the underlying<br />
  category does.
</p></blockquote>
<p>Meaning, we&#8217;re still dealing with finite products.</p>
<p>We&#8217;re also dealing with multisorted Lawvere theories, and that&#8217;s a tougher nut to crack. To get the full, correctly typed (/sorted) theory, we seemingly need infinitely many sorts.<br />
My upcoming approach is, to try to make that, too, work by exploiting the fact, that we are only talking about two generator sorts, W and N, here, so perhaps I can finitely represent all the required sorts. (The biggest challenge here will be the S combinator)</p>
<p>Interestingly, about the sorts, the paper also states:</p>
<blockquote><p>
  A multisorted Gph-enriched Lawvere theory, hereafter<br />
  Gph-theory is a Gph-enriched category with finite products Th equipped with a finite set S of sorts and a Gph-enriched functor θ : FinSetop/S → Th that preserves products strictly.
</p></blockquote>
<p>The set of sorts is also finite. Presumably, things like N-&gt;W aren&#8217;t counted as sorts in that set, then.</p>
<p>Finally, the very first sentence of 4, states:</p>
<blockquote><p>
  Lawvere theories and their generalizations are categories with infinitely many objects and morphisms, but most theories of interest are finitely generated.
</p></blockquote>
<p>Which is vaguely related to my statement above, that most combinator calculi should admit a similar embedding into Globular, because the most interesting ones are finitely generated.</p>
<p>Below that, it states:</p>
<blockquote><p>
  A presentation of the underlying multisorted Lawvere theory of a finitely-generated Gph-theory is a signature for a term calculus, consisting of a set of sorts, a set of term constructors, and a set of equations, while the edges in the hom graphs of the theory encode the reduction relation.
</p></blockquote>
<p>And after that, it presents the SKI combinator calculus as a Gph-theory, doing, as far as I can tell, pretty much 1:1 what I did.</p>
<p>(My single wire is the mentioned set of sorts, the various combinators and the three special morphisms are the set of term constructors, and after that I have the set of equations and reduction relations)</p>
<p>So while I absolutely might be missing something, I think that should pretty much answer Jamie&#8217;s questions about whether this work can be represented in Globular.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: John Baez		</title>
		<link>https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120511</link>

		<dc:creator><![CDATA[John Baez]]></dc:creator>
		<pubDate>Wed, 23 May 2018 23:42:01 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=24839#comment-120511</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016&quot;&gt;Kram Einsnulldreizwei&lt;/a&gt;.

Kram wrote:

&lt;blockquote&gt;
  At a guess that&#039;s because combinator calculi very often are finitely representable (everything can be done with just the finite set of combinators),
&lt;/blockquote&gt;

Jamie said &quot;finitely presentable&quot;, which means something precise.

It&#039;s a bit tiring to say &lt;em&gt;exactly&lt;/em&gt; what a finitely presented &lt;i&gt;n&lt;/i&gt;-category is, but it roughly means:

1) There are finitely many &lt;strong&gt;generators&lt;/strong&gt; - &lt;i&gt;j&lt;/i&gt;-morphisms for various &lt;i&gt;j&lt;/i&gt; from which which all others can be generated using he operations that every &lt;i&gt;n&lt;/i&gt;-category has.

2) There are finitely many &lt;strong&gt;relations&lt;/strong&gt; - equations been &lt;i&gt;j&lt;/i&gt;-morphisms, from which other equations can be deduced.

In general, a &lt;strong&gt;presentation&lt;/strong&gt; is a collection of generators for some algebraic structure, together with a collection of relations.  We say an algebraic structure is &quot;finitely presentable&quot; if it has a presentation with finitely many generators and finitely many relations.

The classic example is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Presentation_of_a_group&quot; rel=&quot;nofollow&quot;&gt;finitely presented group&lt;/a&gt;, and whenever people talk about &quot;finitely presented&quot; algebraic structures this is the paradigm they have in mind.  In a group, the ways you get to &quot;generate&quot; new elements from old are multiplying two elements and taking the inverse of an element.  In other structures, you get to do other things, which must be carefully specified.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016">Kram Einsnulldreizwei</a>.</p>
<p>Kram wrote:</p>
<blockquote><p>
  At a guess that&#8217;s because combinator calculi very often are finitely representable (everything can be done with just the finite set of combinators),
</p></blockquote>
<p>Jamie said &#8220;finitely presentable&#8221;, which means something precise.</p>
<p>It&#8217;s a bit tiring to say <em>exactly</em> what a finitely presented <i>n</i>-category is, but it roughly means:</p>
<p>1) There are finitely many <strong>generators</strong> &#8211; <i>j</i>-morphisms for various <i>j</i> from which which all others can be generated using he operations that every <i>n</i>-category has.</p>
<p>2) There are finitely many <strong>relations</strong> &#8211; equations been <i>j</i>-morphisms, from which other equations can be deduced.</p>
<p>In general, a <strong>presentation</strong> is a collection of generators for some algebraic structure, together with a collection of relations.  We say an algebraic structure is &#8220;finitely presentable&#8221; if it has a presentation with finitely many generators and finitely many relations.</p>
<p>The classic example is a <a href="https://en.wikipedia.org/wiki/Presentation_of_a_group" rel="nofollow">finitely presented group</a>, and whenever people talk about &#8220;finitely presented&#8221; algebraic structures this is the paradigm they have in mind.  In a group, the ways you get to &#8220;generate&#8221; new elements from old are multiplying two elements and taking the inverse of an element.  In other structures, you get to do other things, which must be carefully specified.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Kram Einsnulldreizwei		</title>
		<link>https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120474</link>

		<dc:creator><![CDATA[Kram Einsnulldreizwei]]></dc:creator>
		<pubDate>Wed, 23 May 2018 21:06:17 +0000</pubDate>
		<guid isPermaLink="false">http://johncarlosbaez.wordpress.com/?p=24839#comment-120474</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016&quot;&gt;Kram Einsnulldreizwei&lt;/a&gt;.

Jamie wrote:

&lt;blockquote&gt;
  At the moment general feature development of Globular is frozen, while we develop the next iteration, which will allow computation in infinite-dimensions. (I’m working on this with Christoph Dorn, Christopher Douglas, and David Reutter.)
&lt;/blockquote&gt;

That&#039;s more or less what I figured, and I&#039;m very much looking forward to it! Thanks for your work! Even in its current state, it&#039;s a great help to me, for understanding things simply by building them. And it&#039;s quite incredible, what&#039;s already possible.
As said, many of the features I&#039;d like to see have actually already been suggested by others. But I&#039;ll be sure to add new suggestions, as I spot them. I&#039;ll have to read through the tracker again first, though. (Or is there another place to put suggestions besides Github? - That page apparently hasn&#039;t been updated in a while.)

&lt;blockquote&gt;
  Globular lets you work with any finitely-presented algebraic signature up to dimension 4, as long as the terms are purely compositional.
&lt;/blockquote&gt;

I&#039;m not sure, I fully understand every implication of this, but it seems to me, that a large set of combinator calculi fit this description.

Generally, combinators appear to map quite nicely to Globular as string diagrams similar to how I defined them. All kinds of combinator calculi are possible, actually, as long as the rules don&#039;t become too crazy. (For instance, I once tried to make SF combinators work, but the F-combinator is &lt;em&gt;really&lt;/em&gt; challenging, due to its complicated, case-sensitive application rules. I think it might be possible, and I did get part of the way there, but I&#039;m missing edge cases.)

At a guess that&#039;s because combinator calculi very often are finitely representable (everything can be done with just the finite set of combinators), and compositional. (Any (if required, well-typed) string of combinators and balanced parentheses will be a valid program).

I believe, the three helper objects I need to make it work - Branch, Copy, and Eat, are rarely avoidable. Almost any combinator calculus should be realizable using only those three in addition to the actual combinators. (BCI combinators, being linear, would only require Branch. I&#039;m not sure that one could ever be gotten rid of in a practical manner.)
Unless you have really exotic rules, which certainly is possible.
(There surely is a way to make that mathematically precise. What rules can or can&#039;t be done? What combinator calculi admit these constraints?)

As previously explained, Branch is really the same as parentheses.
If I got that right, it should have the type:
Branch: forall X, Y : (X -&#062; Y) -&#062; X -&#062; Y

Meanwhile, Copy and Eat come up in the S- and K-combinators. Since those are some kind of almost minimal set of combinators, presumably any universal non-linear combinator calculus will need these.
These have the types:
Copy: forall X : X -&#062; X×X
Eat: forall X: X -&#062; 1
I believe, those are the two morphisms a comonoid would have, right?

The 4-dimensional part is also nice in that, usually, I&#039;ll want strings in such a diagram to pass through each other freely, which is best done in 4-cells, where all the relevant rules to manipulate them already are present.

&lt;blockquote&gt;
  It’s possible that Globular can only encode some fragment of the theory, which may still be interesting; in that case, it would be good to be clear exactly what fragment this is.
&lt;/blockquote&gt;

Well, as said, if the Rho combinators can do it (and my understanding is, that they are a full translation of the Rho calculus), what I did thus far will be able to do it as well.

I also already mentioned the caveat in the communication rule. There is an input-side Copy instruction there, which copies an input in order to declare it the same. This is brittle, because it relies on you &lt;em&gt;not&lt;/em&gt; copying something, in order to instead apply the more complicated, and thus perhaps easily unnoticed communication rule. As yet I don&#039;t know how I might make somebody prevent the application of Copy, when they probably would like to do a communication instead.
(* more later)

Specifically, what&#039;s happening is this:
The communication rule states:

((&#124; C) ((&#124; ((for (&#038;P)) Q)) (( ! (&#038;P)) R)) )
-&#062;
((&#124; C) (Q (&#038;R)) )

Or, with fewer parentheses:

C &#124; for (&#038; P) Q &#124; ! (&#038;P) R
-&#062;
C &#124; Q (&#038;R)

Where P is a process, &#038;P is it lifted to a name.
So

! (&#038;P) R

I think, basically calls out &quot;I have something called P!

and

for (&#038;P) Q

says &quot;If I get something called P, I can interpret it!&quot;

And so, R can be communicated as input to Q, which interprets it into another process Q(&#038;R).

The problem is, that (&#038;P) comes up twice. The way I implemented this, inputs are essentially anonymous. (Hence, say, S can be applied without caring about what&#039;s below at all!) - so the only way (I can think of), to tell Globular, that two inputs are actually &lt;em&gt;the same input&lt;/em&gt;, is by copying from a single input.

And presumably, without typing you could build nonsense, such as, I don&#039;t know,
((&#124; C) (&#038; P)) = C &#124; &#038;P
which the types would rule out, because &#038;P has type N (and P has type W), but &#124; only takes things of type W to produce another W.
That&#039;s clearly a flaw with the current design. But one that&#039;ll be really hard to adress without polymorphism support (as per the previous discussion).

Other than those two issues, my current understanding is, that this is an entirely faithful, complete translation of rho-combinators, and therefore of rho calculus.
I might be mistaken though.

In summary, it should have the full power of rho combinators, but it lacks a few necessary constraints to make possible only legal trees of them, and to transform legal trees into ones that still are legal (i.e., they can still reach the same normal form).

Finally, I suppose, since inputs can&#039;t be completely deleted, only &quot;marked for deletion&quot;, it could be argued, that the translation isn&#039;t so perfect after all, even if the above problems were to be sorted out. But that seems like a non-issue to me. If &lt;em&gt;really&lt;/em&gt; necessary, I could always just cap these up on the bottom (input-side) as well, thereby allowing me to actually delete inputs. Mostly that just seems like making things less clean though.
And arguably, knowing how much was thrown away could also be of interest.



(*)
There may be better ways to do the communication rule, but I&#039;d have to have more of an intuition for when any of this even comes up.

Like, the SKI combinators themselves are already Turing complete, right? In principle, I could literally just ignore all the fancy new combinators, and build arbitrary programs in SKI combinators.
And I have a vague intuition for how programs look like when using SKI combinators.

I don&#039;t really have an idea at all for how the same stuff looks like in pi or rho calculus. Or how you&#039;d typically use any of the new elements.
Until I have that, it&#039;s very hard for me to gauge the actual needs which, then, could further inform the design.

For instance, if it turned out, that the availability of communication can easily be gauged, I could potentially constrain Copy-nodes to be sensitive to that. You then could no longer make a premature copying error.

The most obvious idea I have to that effect is, to simply not allow copying &#038;-combinators until communication can be ruled out. But I&#039;m not sure that&#039;s either necessary or sufficient for avoiding these issues. The types ought to allow it at least.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://johncarlosbaez.wordpress.com/2018/05/12/rchain/#comment-120016">Kram Einsnulldreizwei</a>.</p>
<p>Jamie wrote:</p>
<blockquote><p>
  At the moment general feature development of Globular is frozen, while we develop the next iteration, which will allow computation in infinite-dimensions. (I’m working on this with Christoph Dorn, Christopher Douglas, and David Reutter.)
</p></blockquote>
<p>That&#8217;s more or less what I figured, and I&#8217;m very much looking forward to it! Thanks for your work! Even in its current state, it&#8217;s a great help to me, for understanding things simply by building them. And it&#8217;s quite incredible, what&#8217;s already possible.<br />
As said, many of the features I&#8217;d like to see have actually already been suggested by others. But I&#8217;ll be sure to add new suggestions, as I spot them. I&#8217;ll have to read through the tracker again first, though. (Or is there another place to put suggestions besides Github? &#8211; That page apparently hasn&#8217;t been updated in a while.)</p>
<blockquote><p>
  Globular lets you work with any finitely-presented algebraic signature up to dimension 4, as long as the terms are purely compositional.
</p></blockquote>
<p>I&#8217;m not sure, I fully understand every implication of this, but it seems to me, that a large set of combinator calculi fit this description.</p>
<p>Generally, combinators appear to map quite nicely to Globular as string diagrams similar to how I defined them. All kinds of combinator calculi are possible, actually, as long as the rules don&#8217;t become too crazy. (For instance, I once tried to make SF combinators work, but the F-combinator is <em>really</em> challenging, due to its complicated, case-sensitive application rules. I think it might be possible, and I did get part of the way there, but I&#8217;m missing edge cases.)</p>
<p>At a guess that&#8217;s because combinator calculi very often are finitely representable (everything can be done with just the finite set of combinators), and compositional. (Any (if required, well-typed) string of combinators and balanced parentheses will be a valid program).</p>
<p>I believe, the three helper objects I need to make it work &#8211; Branch, Copy, and Eat, are rarely avoidable. Almost any combinator calculus should be realizable using only those three in addition to the actual combinators. (BCI combinators, being linear, would only require Branch. I&#8217;m not sure that one could ever be gotten rid of in a practical manner.)<br />
Unless you have really exotic rules, which certainly is possible.<br />
(There surely is a way to make that mathematically precise. What rules can or can&#8217;t be done? What combinator calculi admit these constraints?)</p>
<p>As previously explained, Branch is really the same as parentheses.<br />
If I got that right, it should have the type:<br />
Branch: forall X, Y : (X -&gt; Y) -&gt; X -&gt; Y</p>
<p>Meanwhile, Copy and Eat come up in the S- and K-combinators. Since those are some kind of almost minimal set of combinators, presumably any universal non-linear combinator calculus will need these.<br />
These have the types:<br />
Copy: forall X : X -&gt; X×X<br />
Eat: forall X: X -&gt; 1<br />
I believe, those are the two morphisms a comonoid would have, right?</p>
<p>The 4-dimensional part is also nice in that, usually, I&#8217;ll want strings in such a diagram to pass through each other freely, which is best done in 4-cells, where all the relevant rules to manipulate them already are present.</p>
<blockquote><p>
  It’s possible that Globular can only encode some fragment of the theory, which may still be interesting; in that case, it would be good to be clear exactly what fragment this is.
</p></blockquote>
<p>Well, as said, if the Rho combinators can do it (and my understanding is, that they are a full translation of the Rho calculus), what I did thus far will be able to do it as well.</p>
<p>I also already mentioned the caveat in the communication rule. There is an input-side Copy instruction there, which copies an input in order to declare it the same. This is brittle, because it relies on you <em>not</em> copying something, in order to instead apply the more complicated, and thus perhaps easily unnoticed communication rule. As yet I don&#8217;t know how I might make somebody prevent the application of Copy, when they probably would like to do a communication instead.<br />
(* more later)</p>
<p>Specifically, what&#8217;s happening is this:<br />
The communication rule states:</p>
<p>((| C) ((| ((for (&amp;P)) Q)) (( ! (&amp;P)) R)) )<br />
-&gt;<br />
((| C) (Q (&amp;R)) )</p>
<p>Or, with fewer parentheses:</p>
<p>C | for (&amp; P) Q | ! (&amp;P) R<br />
-&gt;<br />
C | Q (&amp;R)</p>
<p>Where P is a process, &amp;P is it lifted to a name.<br />
So</p>
<p>! (&amp;P) R</p>
<p>I think, basically calls out &#8220;I have something called P!</p>
<p>and</p>
<p>for (&amp;P) Q</p>
<p>says &#8220;If I get something called P, I can interpret it!&#8221;</p>
<p>And so, R can be communicated as input to Q, which interprets it into another process Q(&amp;R).</p>
<p>The problem is, that (&amp;P) comes up twice. The way I implemented this, inputs are essentially anonymous. (Hence, say, S can be applied without caring about what&#8217;s below at all!) &#8211; so the only way (I can think of), to tell Globular, that two inputs are actually <em>the same input</em>, is by copying from a single input.</p>
<p>And presumably, without typing you could build nonsense, such as, I don&#8217;t know,<br />
((| C) (&amp; P)) = C | &amp;P<br />
which the types would rule out, because &amp;P has type N (and P has type W), but | only takes things of type W to produce another W.<br />
That&#8217;s clearly a flaw with the current design. But one that&#8217;ll be really hard to adress without polymorphism support (as per the previous discussion).</p>
<p>Other than those two issues, my current understanding is, that this is an entirely faithful, complete translation of rho-combinators, and therefore of rho calculus.<br />
I might be mistaken though.</p>
<p>In summary, it should have the full power of rho combinators, but it lacks a few necessary constraints to make possible only legal trees of them, and to transform legal trees into ones that still are legal (i.e., they can still reach the same normal form).</p>
<p>Finally, I suppose, since inputs can&#8217;t be completely deleted, only &#8220;marked for deletion&#8221;, it could be argued, that the translation isn&#8217;t so perfect after all, even if the above problems were to be sorted out. But that seems like a non-issue to me. If <em>really</em> necessary, I could always just cap these up on the bottom (input-side) as well, thereby allowing me to actually delete inputs. Mostly that just seems like making things less clean though.<br />
And arguably, knowing how much was thrown away could also be of interest.</p>
<p>(*)<br />
There may be better ways to do the communication rule, but I&#8217;d have to have more of an intuition for when any of this even comes up.</p>
<p>Like, the SKI combinators themselves are already Turing complete, right? In principle, I could literally just ignore all the fancy new combinators, and build arbitrary programs in SKI combinators.<br />
And I have a vague intuition for how programs look like when using SKI combinators.</p>
<p>I don&#8217;t really have an idea at all for how the same stuff looks like in pi or rho calculus. Or how you&#8217;d typically use any of the new elements.<br />
Until I have that, it&#8217;s very hard for me to gauge the actual needs which, then, could further inform the design.</p>
<p>For instance, if it turned out, that the availability of communication can easily be gauged, I could potentially constrain Copy-nodes to be sensitive to that. You then could no longer make a premature copying error.</p>
<p>The most obvious idea I have to that effect is, to simply not allow copying &amp;-combinators until communication can be ruled out. But I&#8217;m not sure that&#8217;s either necessary or sufficient for avoiding these issues. The types ought to allow it at least.</p>
]]></content:encoded>
		
			</item>
	</channel>
</rss>
